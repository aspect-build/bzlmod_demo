diff --git a/node_modules/@bazel/typescript/internal/ts_project.bzl b/node_modules/@bazel/typescript/internal/ts_project.bzl
index 311b77d..079f218 100755
--- a/node_modules/@bazel/typescript/internal/ts_project.bzl
+++ b/node_modules/@bazel/typescript/internal/ts_project.bzl
@@ -3,17 +3,22 @@
 load("@build_bazel_rules_nodejs//:providers.bzl", "DeclarationInfo", "ExternalNpmPackageInfo", "declaration_info", "js_module_info", "run_node")
 load("@build_bazel_rules_nodejs//internal/linker:link_node_modules.bzl", "module_mappings_aspect")
 load("@build_bazel_rules_nodejs//internal/node:node.bzl", "nodejs_binary")
+load("@bazel_skylib//lib:partial.bzl", "partial")
 load(":ts_config.bzl", "TsConfigInfo", "write_tsconfig")
 
 _ValidOptionsInfo = provider()
 
 _DEFAULT_TSC = (
-    
+    # BEGIN-INTERNAL
+    "@npm" +
+    # END-INTERNAL
     "//typescript/bin:tsc"
 )
 
 _DEFAULT_TYPESCRIPT_PACKAGE = (
-    
+    # BEGIN-INTERNAL
+    "@npm" +
+    # END-INTERNAL
     "//typescript"
 )
 
@@ -175,6 +180,10 @@ def _ts_project_impl(ctx):
     else:
         json_outs = []
 
+        # If there are no js_outs, that implies we are producing declarations only.
+        # We must avoid tsc writing any JS files in this case, as it was only run for typings.
+        arguments.add("--emitDeclarationOnly")
+
     outputs = json_outs + ctx.outputs.js_outs + ctx.outputs.map_outs + ctx.outputs.typings_outs + ctx.outputs.typing_maps_outs
     if ctx.outputs.buildinfo_out:
         arguments.add_all([
@@ -312,7 +321,7 @@ validate_options = rule(
         "target": attr.string(),
         "ts_build_info_file": attr.string(),
         "tsconfig": attr.label(mandatory = True, allow_single_file = [".json"]),
-        "validator": attr.label(default = Label("//@bazel/typescript/bin:ts_project_options_validator"), executable = True, cfg = "host"),
+        "validator": attr.label(default = Label("//packages/typescript/bin:ts_project_options_validator"), executable = True, cfg = "host"),
     },
 )
 
@@ -363,6 +372,7 @@ def ts_project_macro(
         composite = False,
         incremental = False,
         emit_declaration_only = False,
+        transpiler = "tsc",
         ts_build_info_file = None,
         tsc = None,
         typescript_package = _DEFAULT_TYPESCRIPT_PACKAGE,
@@ -536,6 +546,28 @@ def ts_project_macro(
 
         args: List of strings of additional command-line arguments to pass to tsc.
 
+        transpiler: What tool to run that produces the JavaScript outputs.
+            By default, this is the string `tsc`. With that value, `ts_project` expects `.js` outputs
+            to be written in the same action that does the type-checking to produce `.d.ts` outputs.
+            This is the simplest configuration, however `tsc` is slower than alternatives.
+            It also means developers must wait for the type-checking in the developer loop.
+
+            In theory, Persistent Workers (via the `supports_workers` attribute) remedies the
+            slow compilation time, however it adds additional complexity because the worker process
+            can only see one set of dependencies, and so it cannot be shared between different
+            `ts_project` rules. That attribute is documented as experimental, and may never graduate
+            to a better support contract.
+
+            Instead of the string `tsc`, this attribute also accepts a rule or macro with this signature:
+            `name, srcs, js_outs, map_outs, **kwargs`
+            where the `**kwargs` attribute propagates the tags, visibility, and testonly attributes from `ts_project`.
+
+            If you need to pass additional attributes to the transpiler rule, you can use a
+            [partial](https://github.com/bazelbuild/bazel-skylib/blob/main/lib/partial.bzl)
+            to bind those arguments at the "make site", then pass that partial to this attribute where it
+            will be called with the remaining arguments.
+            See the packages/typescript/test/ts_project/swc directory for an example.
+
         tsc: Label of the TypeScript compiler binary to run.
 
             For example, `tsc = "@my_deps//typescript/bin:tsc"`
@@ -702,13 +734,24 @@ def ts_project_macro(
         nodejs_binary(
             name = tsc_worker,
             data = [
-                
+                # BEGIN-INTERNAL
+                # Users get this dependency transitively from @bazel/typescript
+                # but that's our own code, so we don't.
+                # TODO: remove protobuf dependency once rules_typescript also uses
+                # worker package
+                "@npm//protobufjs",
+                # END-INTERNAL
                 Label(typescript_package),
-                Label("//@bazel/typescript"),
-                
+                Label("//packages/typescript/internal/worker:filegroup"),
+                # BEGIN-INTERNAL
+                # this is not needed when package since @bazel/typescript lists
+                # @bazel/worker as its dependency hence has access to it.
+                # this only needed when ts_project is run from the source.
+                Label("//packages/worker:library"),
+                # END-INTERNAL
                 tsconfig,
             ],
-            entry_point = Label("//@bazel/typescript/internal/worker:index.js"),
+            entry_point = Label("//packages/typescript/internal/worker:worker_adapter"),
             templated_args = [
                 "--typescript_require_path",
                 typescript_require_path,
@@ -741,7 +784,38 @@ def ts_project_macro(
     if declaration_map:
         typing_maps_outs.extend(_out_paths(srcs, typings_out_dir, root_dir, allow_js, {"*": ".d.ts.map"}))
 
-    if not len(js_outs) and not len(typings_outs):
+    tsc_js_outs = []
+    tsc_map_outs = []
+    if transpiler == "tsc":
+        tsc_js_outs = js_outs
+        tsc_map_outs = map_outs
+    else:
+        transpiler_kwargs = {
+            "tags": kwargs.get("tags", []),
+            "visibility": kwargs.get("visibility", None),
+            "testonly": kwargs.get("testonly", None),
+        }
+        if type(transpiler) == "function" or type(transpiler) == "rule":
+            transpiler(
+                name = name + "_transpile",
+                srcs = srcs,
+                js_outs = js_outs,
+                map_outs = map_outs,
+                **transpiler_kwargs
+            )
+        elif partial.is_instance(transpiler):
+            partial.call(
+                transpiler,
+                name = name + "_transpile",
+                srcs = srcs,
+                js_outs = js_outs,
+                map_outs = map_outs,
+                **transpiler_kwargs
+            )
+        else:
+            fail("transpiler attribute should be a rule/macro, a skylib partial, or the string 'tsc'. Got " + type(transpiler))
+
+    if not len(tsc_js_outs) and not len(typings_outs):
         fail("""ts_project target "//{}:{}" is configured to produce no outputs.
 
 Note that ts_project must know the srcs in advance in order to predeclare the outputs.
@@ -758,8 +832,8 @@ Check the srcs attribute to see that some .ts files are present (or .js files wi
         declaration_dir = declaration_dir,
         out_dir = out_dir,
         root_dir = root_dir,
-        js_outs = js_outs,
-        map_outs = map_outs,
+        js_outs = tsc_js_outs,
+        map_outs = tsc_map_outs,
         typings_outs = typings_outs,
         typing_maps_outs = typing_maps_outs,
         buildinfo_out = tsbuildinfo_path if composite or incremental else None,
